<!DOCTYPE html>
<html lang="pl-PL" xmlns="http://www.w3.org/1999/html">
<head>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser-arcade-physics.min.js"></script>
    <title>Simple Mario</title>
</head>
<body>

<script>

    TILE = 1
    PLAYER = 500
    POINT = 1000
    ENEMY = 1500

    class SimpleLevel extends Phaser.Scene
    {
        player;
        cursors;
        initialPlayerPosition;
        map;
        tiles;
        layer;
        levelData;
        tileSize = 32;
        bestScore;
        bestScoreText;
        score;
        scoreText;
        points;
        listOfPoints = [];
        enemies;
        listOfEnemies = [];
        healthBar;
        maxHealthValue = 90;
        healthValue = 90;
        healthValueText;
        lastHitTime = 0;
        hitCooldown = 1000;
        enemySpeed = 30;
        tileXCount = 25;
        tileYCount = 18;

        initBoard(){

            let levelDate = []
            for(let i=0; i< this.tileYCount; i++){
                levelDate[i] = []
                for(let j=0; j<this.tileXCount; j++){
                    levelDate[i][j]= -1;
                }
            }

            levelDate[5][23]=TILE;
            levelDate[5][24]=TILE;
            levelDate[4][23]=POINT;
            levelDate[4][24]=ENEMY;

            levelDate[6][14]=TILE;
            levelDate[6][19]=TILE;
            levelDate[5][19]=ENEMY;
            levelDate[6][8]=POINT;

            levelDate[7][7]=TILE;
            levelDate[7][8]=TILE;
            levelDate[7][9]=TILE;
            levelDate[7][0]=ENEMY;


            levelDate[8][0]=TILE;
            levelDate[8][1]=TILE;
            levelDate[8][2]=TILE;

            levelDate[9][2]=TILE;
            levelDate[9][3]=TILE;
            levelDate[10][7]=TILE;
            levelDate[10][8]=TILE;

            levelDate[10][15]=POINT;
            levelDate[10][14]=ENEMY;

            levelDate[11][14]=TILE;
            levelDate[11][15]=TILE;
            levelDate[11][16]=TILE;
            levelDate[11][17]=TILE;

            levelDate[12][19]=TILE;

            levelDate[13][21]=TILE;

            levelDate[14][6]=TILE;
            levelDate[14][24]=TILE;

            levelDate[15][0]=PLAYER;
            levelDate[15][2]=TILE;
            levelDate[15][6]=TILE;
            levelDate[15][7]=TILE;
            levelDate[15][10]=POINT;
            levelDate[15][14]=ENEMY;

            levelDate[15][23]=TILE;
            levelDate[15][24]=TILE;

            levelDate[16][0]=TILE;
            levelDate[16][1]=TILE;
            levelDate[16][2]=TILE;
            levelDate[16][3]=TILE;
            levelDate[16][6]=TILE;
            levelDate[16][7]=TILE;
            levelDate[16][8]=TILE;
            levelDate[16][9]=TILE;
            levelDate[16][10]=TILE;
            levelDate[16][13]=TILE;
            levelDate[16][14]=TILE;
            levelDate[16][15]=TILE;
            levelDate[16][16]=TILE;
            levelDate[16][22]=TILE;
            levelDate[16][23]=TILE;
            levelDate[16][24]=TILE;

            levelDate[17][3]=TILE;
            levelDate[17][6]=TILE;
            levelDate[17][10]=TILE;
            levelDate[17][13]=TILE;
            levelDate[17][16]=TILE;
            levelDate[17][22]=TILE;

            return levelDate
        }
        fillBoardWithPieces(){
            this.levelData.forEach((row, rowIndex) => {
                row.forEach((tileValue, columnIndex) => {
                    if (tileValue === TILE) {
                        this.layer.putTileAt(tileValue, columnIndex, rowIndex);
                        this.map.setCollisionBetween(tileValue, tileValue, true, this.layer);
                    }else if (tileValue === POINT){
                        let position = this.calculate_pixels(rowIndex,columnIndex);
                        this.addPointToMap(position.x,position.y)
                    }else if (tileValue === ENEMY){
                        let position = this.calculate_pixels(rowIndex,columnIndex);
                        let borders = this.getPlatformUnderEnemy(rowIndex,columnIndex)
                        let leftBorder = this.calculate_pixels(rowIndex,borders.MaxLeft);
                        let rightBorder = this.calculate_pixels(rowIndex,borders.MaxRight);
                        this.addEnemyToMap(position.x,position.y,leftBorder.x,rightBorder.x)
                    }
                });
            });
        }
        preload(){
            this.load.setBaseURL('https://labs.phaser.io');

            this.load.image('sky', 'assets/skies/clouds.png');
            this.load.image('walls_1x2', 'assets/tilemaps/tiles/ground_1x1.png');
            this.load.image('player', 'assets/sprites/pangball.png');
            this.load.image('point', 'assets/sprites/shinyball.png');
            this.load.image('enemy', 'assets/sprites/mine.png');
        }
        init()
        {
            this.add.image(400, 300, 'sky');
            this.initialPlayerPosition = { x: 0, y: 480 };
            this.map = this.make.tilemap({ width: 200, height: 200, tileWidth: 32, tileHeight: 32 });
            this.tiles = this.map.addTilesetImage('walls_1x2', null, 32, 32);
            this.layer = this.map.createBlankLayer('layer1', this.tiles);
            this.player = this.physics.add.sprite(this.initialPlayerPosition.x, this.initialPlayerPosition.y, 'player');
            this.player.setBounce(0.2);
            this.player.setCollideWorldBounds(true);
            this.levelData = this.initBoard();

            this.scoreText = this.add.text(10, 10, 'Score: 0', { fontFamily: 'Arial', fontSize: 24, color: '#000000' });
            this.score = 0;
            this.bestScoreText = this.add.text(10, 40, 'Best Score: 0', { fontFamily: 'Arial', fontSize: 24, color: '#000000' });
            this.bestScore = 0;
            this.points = this.physics.add.group();
            this.enemies = this.physics.add.group();
            this.cursors = this.input.keyboard.createCursorKeys();
            this.physics.add.collider(this.player, this.layer);
            this.physics.add.collider(this.points, this.layer);
            this.physics.add.collider(this.enemies, this.layer);
            this.physics.add.overlap(this.player, this.points, this.collectPoint, null, this);
            this.healthBar =  this.makeBar(575, 25)
            this.setHealthBarUIValue()
        }
        create (){
            this.init()
            this.fillBoardWithPieces()
        }

        update(time, delta)
        {
            if (this.cursors.left.isDown) {
                this.player.setVelocityX(-160);
            } else if (this.cursors.right.isDown) {
                this.player.setVelocityX(160);
            } else {
                this.player.setVelocityX(0);
            }

            if (this.cursors.up.isDown && this.player.body.onFloor()) {
                this.player.setVelocityY(-135);
            }else if (this.cursors.down.isDown) {
                this.player.setVelocityY(135);
            }
            if (this.player.y >= this.sys.game.config.height-this.tileSize) {
                this.handlePlayerDeath();
            }
            var tileSize = this.tileSize;
            var enemySpeed= this.enemySpeed;
            this.listOfEnemies.forEach(function(enemy) {
                if(enemy.leftBorder === enemy.rightBorder && enemy.enemy.body.onFloor())
                    enemy.enemy.setVelocityY(-180)
                else{
                    if (enemy.enemy.x<= enemy.leftBorder)
                        enemy.enemy.setVelocityX(enemySpeed);
                    else if (enemy.enemy.x>= enemy.rightBorder)
                        enemy.enemy.setVelocityX(-enemySpeed);
                }
            },this);
            this.listOfEnemies.forEach(function(enemy) {
                if (enemy.enemy.y > game.config.height - tileSize) {
                    enemy.enemy.disableBody(true, true);
                }
            }, this);
        }

        handlePlayerDeath(){
           this.respawnPlayer();
           this.reInitHealthBar();
           this.setAndReRenderScores();
           this.respawnPoints();
           this.respawnEnemies();
        }
        handleGetHit(player, enemy){
            if (this.player.body.touching.down && enemy.body.touching.up) {
                enemy.disableBody(true, true);
                this.player.setVelocityY(-235);
                this.score += 50;
                this.scoreText.setText('Score: ' + this.score);
            }else{
                if (game.getTime() - this.lastHitTime < this.hitCooldown) {
                    return;
                }
                this.healthValue -=30
                this.setHealthBarUIValue();
                if(this.healthValue === 0)
                    this.handlePlayerDeath()

                this.lastHitTime = game.getTime();
            }
        }
        reInitHealthBar(){
            this.healthValue = 90;
            this.setHealthBarUIValue()
        }
        respawnPlayer(){
            this.player.setVisible(false);
            this.player.setPosition(this.initialPlayerPosition.x, this.initialPlayerPosition.y);
            this.player.setVisible(true);
        }
        respawnEnemies(){
            this.listOfEnemies.forEach((enemy) => {
                enemy.enemy.disableBody(true, true);
                enemy.enemy.enableBody(true, enemy.enemy.x, enemy.enemy.y, true, true);
                enemy.enemy.setVelocityX(this.enemySpeed);
            });
        }
        respawnPoints(){
            this.listOfPoints.forEach((point) => {
                point.enableBody(true, point.x, point.y, true, true);
            });
        }
        setAndReRenderScores(){
            if(this.score > this.bestScore){
                this.bestScore = this.score;
                this.bestScoreText.setText('BestScore: ' + this.bestScore);
            }
            this.score = 0;
            this.scoreText.setText('Score: '+ this.score);
        }
        addPointToMap(x, y){
            let point = this.points.create(x, y, 'point');
            point.setInteractive();
            this.listOfPoints.push(point)
            this.physics.add.overlap(this.player, point, this.collectPoint, null, this);
        }
        addEnemyToMap(x, y,leftBorder, rightBorder){
            let enemy = this.enemies.create(x, y, 'enemy');
            enemy.setInteractive(false);
            enemy.setCollideWorldBounds(true);
            enemy.setVelocityX(this.enemySpeed);
            this.listOfEnemies.push({"enemy":enemy, "leftBorder":leftBorder,"rightBorder":rightBorder})
            this.physics.add.collider(this.player, enemy, this.handleGetHit, null, this);

        }
        collectPoint(player, point){
            point.disableBody(true, true);
            this.increaseScore()
        }
        increaseScore() {
            this.score+=100;
            this.scoreText.setText('Score: ' + this.score);
        }
        calculate_pixels(row, column) {
            let x=this.tileSize/2;
            let y=this.tileSize/2;
            let tileX = 0;
            let tileY = 0;
            if(row!==0){
                tileY = this.tileSize;
                tileY=tileY*row
            }
            if(column!==0){
                tileX = this.tileSize;
                tileX=tileX*column
            }
            return {"x":x+tileX, "y":y+tileY}
        }
        makeBar(x, y) {
            let bar = this.add.graphics();
            bar.fillStyle(0xFF0000, 1);
            bar.fillRect(0, 0, 200, 25);
            bar.x = x;
            bar.y = y;

            let outlines = this.add.graphics();
            outlines.lineStyle(4, 0x000000);
            outlines.strokeRect(0, 0, 200, 25);
            outlines.x = x;
            outlines.y = y;

            this.healthValueText = this.add.text(625, 25,'Health: 90', { fontFamily: 'Arial', fontSize: 24, color: '#000000' })

            return bar;
        }
        setHealthBarUIValue() {
            this.healthBar.scaleX = this.healthValue / this.maxHealthValue;
            this.healthValueText.setText('Health: ' + this.healthValue);
        }
        getPlatformUnderEnemy(row, column){
            if(row===0)
                return;
            let underRow = row+1;
            let maxLeft = column;
            let maxRight = column;
            for(let i= column; i>=0;i--){
                maxLeft=i;
                if(this.levelData[underRow][i]===TILE){
                    continue;
                }
                break;
            }
            for(let i= column; i<this.tileXCount;i++){
                maxRight=i;
                if(this.levelData[underRow][i]===TILE)
                    continue;
                break;
            }

            return {"MaxLeft":maxLeft===0 ? maxLeft : maxLeft+1, "MaxRight": maxRight===this.tileXCount-1 ? maxRight : maxRight-1}
        }
    }

    config = {
        type: Phaser.AUTO,
        width: 800,
        height: 570,
        scene: SimpleLevel,
        pixelArt: true,
        physics: {
            default: 'arcade',
            arcade: {
                gravity: { y: 200 }
            }
        }
    };

    game = new Phaser.Game(config);

</script>

</body>
</html>