<!DOCTYPE html>
<html lang="pl-PL" xmlns="http://www.w3.org/1999/html">
<head>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser-arcade-physics.min.js"></script>
    <title>Simple Mario</title>
</head>
<body>
<button id="loadLevels"> Load Levels</button>
<label for="levelsInput">Select a levels:</label></br>
<input type="file" id="levelsInput" name="level" accept="text/plain" multiple>
<button id="basicGame">Play hardcoded level</button>
<script>

    function handleLoadLevelsButtonClick() {
        deleteCanvases()
        deleteGame()
        let files = document.getElementById("levelsInput").files
        loadLevelsMode = true;
        levels = []
        for (let file of files) {
            readMapFile(file);
        }
        game = new Phaser.Game(config);
    }
    function handleBasicGameButtonClick() {
        deleteCanvases()
        deleteGame()
        loadLevelsMode = false;
        game = new Phaser.Game(config);
    }
    function deleteCanvases(){
        let canvasElements = document.getElementsByTagName('canvas');

        for (let i = 0; i < canvasElements.length; i++) {
            let canvas = canvasElements[i];
            canvas.parentNode.removeChild(canvas);
        }
    }
    function deleteGame(){
        if(game)
            game.destroy()
    }
    function readMapFile(file) {
        const reader = new FileReader();
        let levelDate = []
        reader.onload = function(event) {
            const result = event.target.result;
            const lines = result.trim().split('\n');
            let value = EMPTY;
            for(let i=0; i< lines.length; i++){
                levelDate[i] = []
                const columns = lines[i].trim().split(',');
                for(let j=0; j<columns.length; j++){
                    columns[j] = columns[j].trim();
                    if(columns[j] === '-1')
                        value = EMPTY;
                    else if (columns[j] === '1')
                        value = TILE;
                    else if (columns[j] === '500')
                        value = PLAYER
                    else if (columns[j] === '1000')
                        value = POINT
                    else if (columns[j] === '1500')
                        value = ENEMY
                    else
                        value = EMPTY
                    levelDate[i][j] = value;
                }
            }
            levels.push(levelDate)
        };

        reader.onerror = function(event) {
            console.error(`Błąd podczas odczytu pliku ${file.name}`);
        };

        reader.readAsText(file);
        return levelDate
    }

    document.getElementById("loadLevels").addEventListener("click", handleLoadLevelsButtonClick);
    document.getElementById("basicGame").addEventListener("click", handleBasicGameButtonClick);
    EMPTY = -1
    TILE = 1
    PLAYER = 500
    POINT = 1000
    ENEMY = 1500
    loadLevelsMode = false;
    let levels = []
    game = null
    class SimpleLevel extends Phaser.Scene
    {
        player;
        cursors;
        initialPlayerPosition;
        map;
        tiles;
        layer;
        levelData;
        tileSize = 32;
        bestScore;
        bestScoreText;
        score;
        scoreText;
        points;
        listOfPoints = [];
        enemies;
        listOfEnemies = [];
        healthBar;
        maxHealthValue = 90;
        healthValue = 90;
        healthValueText;
        lastHitTime = 0;
        hitCooldown = 1000;
        enemySpeed = 30;
        tileXCount = 25;
        tileYCount = 18;
        initPlayerX = 0;
        initPlayerY = 0;
        allEnemiesDisabled = false;
        allPointsDisabled = false;
        currentLevel = 0;
        levelsCount = 0;
        initBoard(){

            let levelDate = []
            for(let i=0; i< this.tileYCount; i++){
                levelDate[i] = []
                for(let j=0; j<this.tileXCount; j++){
                    levelDate[i][j]= -1;
                }
            }

            return levelDate
        }
        hardCodedLevel(levelDate){
            levelDate[5][23]=TILE;
            levelDate[5][24]=TILE;
            levelDate[4][23]=POINT;
            levelDate[4][24]=ENEMY;

            levelDate[6][14]=TILE;
            levelDate[6][19]=TILE;
            levelDate[5][19]=ENEMY;
            levelDate[6][8]=POINT;

            levelDate[7][7]=TILE;
            levelDate[7][8]=TILE;
            levelDate[7][9]=TILE;
            levelDate[7][0]=ENEMY;


            levelDate[8][0]=TILE;
            levelDate[8][1]=TILE;
            levelDate[8][2]=TILE;

            levelDate[9][2]=TILE;
            levelDate[9][3]=TILE;
            levelDate[10][7]=TILE;
            levelDate[10][8]=TILE;

            levelDate[10][15]=POINT;
            levelDate[10][14]=ENEMY;

            levelDate[11][14]=TILE;
            levelDate[11][15]=TILE;
            levelDate[11][16]=TILE;
            levelDate[11][17]=TILE;

            levelDate[12][19]=TILE;

            levelDate[13][21]=TILE;

            levelDate[14][6]=TILE;
            levelDate[14][24]=TILE;

            levelDate[15][0]=PLAYER;
            levelDate[15][2]=TILE;
            levelDate[15][6]=TILE;
            levelDate[15][7]=TILE;
            levelDate[15][10]=POINT;
            levelDate[15][14]=ENEMY;


            levelDate[15][23]=TILE;
            levelDate[15][24]=TILE;

            levelDate[16][0]=TILE;
            levelDate[16][1]=TILE;
            levelDate[16][2]=TILE;
            levelDate[16][3]=TILE;
            levelDate[16][6]=TILE;
            levelDate[16][7]=TILE;
            levelDate[16][8]=TILE;
            levelDate[16][9]=TILE;
            levelDate[16][10]=TILE;
            levelDate[16][13]=TILE;
            levelDate[16][14]=TILE;
            levelDate[16][15]=TILE;
            levelDate[16][16]=TILE;
            levelDate[16][22]=TILE;
            levelDate[16][23]=TILE;
            levelDate[16][24]=TILE;

            levelDate[17][3]=TILE;
            levelDate[17][6]=TILE;
            levelDate[17][10]=TILE;
            levelDate[17][13]=TILE;
            levelDate[17][16]=TILE;
            levelDate[17][22]=TILE;
        }
        fillBoardWithPieces(){
            this.levelData.forEach((row, rowIndex) => {
                row.forEach((tileValue, columnIndex) => {
                    if (tileValue === TILE) {
                        this.layer.putTileAt(tileValue, columnIndex, rowIndex);
                        this.map.setCollisionBetween(tileValue, tileValue, true, this.layer);
                    }else if (tileValue === POINT){
                        let position = this.calculate_pixels(rowIndex,columnIndex);
                        this.addPointToMap(position.x,position.y)
                    }else if (tileValue === ENEMY){
                        let position = this.calculate_pixels(rowIndex,columnIndex);
                        let borders = this.getPlatformUnderEnemy(rowIndex,columnIndex)
                        let leftBorder = this.calculate_pixels(rowIndex,borders.MaxLeft);
                        let rightBorder = this.calculate_pixels(rowIndex,borders.MaxRight);
                        this.addEnemyToMap(position.x,position.y,leftBorder.x,rightBorder.x)
                    }else if (tileValue === PLAYER){
                        let position = this.calculate_pixels(rowIndex,columnIndex);
                        this.initialPlayerPosition.x = position.x;
                        this.initialPlayerPosition.y = position.y;
                    }
                });
            });
        }
        preload(){
            this.load.setBaseURL('https://labs.phaser.io');

            this.load.image('sky', 'assets/skies/clouds.png');
            this.load.image('walls_1x2', 'assets/tilemaps/tiles/ground_1x1.png');
            this.load.image('player', 'assets/sprites/pangball.png');
            this.load.image('point', 'assets/sprites/shinyball.png');
            this.load.image('enemy', 'assets/sprites/mine.png');
        }
        init()
        {
            this.add.image(400, 300, 'sky');

            this.map = this.make.tilemap({ width: 200, height: 200, tileWidth: 32, tileHeight: 32 });
            this.tiles = this.map.addTilesetImage('walls_1x2', null, 32, 32);
            this.layer = this.map.createBlankLayer('layer1', this.tiles);
            this.initialPlayerPosition = { x: this.initPlayerX, y: this.initPlayerY };

            this.player = this.physics.add.sprite(this.initialPlayerPosition.x, this.initialPlayerPosition.y, 'player');

            this.points = this.physics.add.group();
            this.enemies = this.physics.add.group();
            this.cursors = this.input.keyboard.createCursorKeys();
            this.player.setBounce(0.2);
            this.player.setCollideWorldBounds(true);
            this.physics.add.collider(this.player, this.layer);
            this.physics.add.overlap(this.player, this.points, this.collectPoint, null, this);
            this.physics.add.collider(this.points, this.layer);
            this.physics.add.collider(this.enemies, this.layer);
            this.healthBar =  this.makeBar(575, 25)
            this.setHealthBarUIValue()
        }
        initScores(){
            this.scoreText = this.add.text(10, 10, 'Score: 0', { fontFamily: 'Arial', fontSize: 24, color: '#000000' });
            this.score = 0;
            this.bestScoreText = this.add.text(10, 40, 'Best Score: 0', { fontFamily: 'Arial', fontSize: 24, color: '#000000' });
            this.bestScore = 0;
        }
        initScoresText(){
            this.scoreText = this.add.text(10, 10, 'Score: ' + this.score, { fontFamily: 'Arial', fontSize: 24, color: '#000000' });
            this.bestScoreText = this.add.text(10, 40, 'Best Score: ' + this.bestScore, { fontFamily: 'Arial', fontSize: 24, color: '#000000' });
        }
        create (){
            if (!loadLevelsMode){
                this.levelData = this.initBoard();
                this.hardCodedLevel(this.levelData)
            }else{
                this.levelsCount = levels.length
                this.levelData = levels[this.currentLevel]
            }

            this.init()
            this.initScores()
            this.fillBoardWithPieces()
            this.respawnPlayer()
        }

        update(time, delta)
        {
            if (this.cursors.left.isDown) {
                this.player.setVelocityX(-160);
            } else if (this.cursors.right.isDown) {
                this.player.setVelocityX(160);
            } else {
                this.player.setVelocityX(0);
            }

            if (this.cursors.up.isDown && this.player.body.onFloor()) {
                this.player.setVelocityY(-135);
            }else if (this.cursors.down.isDown) {
                this.player.setVelocityY(135);
            }
            if (this.player.y >= this.sys.game.config.height-this.tileSize) {
                this.handlePlayerDeath();
            }
            var tileSize = this.tileSize;
            var enemySpeed= this.enemySpeed;
            this.listOfEnemies.forEach(function(enemy) {
                if(enemy.leftBorder === enemy.rightBorder && enemy.enemy.body.onFloor())
                    enemy.enemy.setVelocityY(-180)
                else if (enemy.enemy.y > game.config.height - tileSize) {
                    enemy.enemy.disableBody(true, true);
                }
                else{
                    if (enemy.enemy.x<= enemy.leftBorder || enemy.enemy.body.blocked.left)
                        enemy.enemy.setVelocityX(enemySpeed);
                    else if (enemy.enemy.x>= enemy.rightBorder || enemy.enemy.body.blocked.right)
                        enemy.enemy.setVelocityX(-enemySpeed);
                }
            },this);
        }
        nextLevel(){
            this.physics.pause();
            var levelPassed = this.add.text(400, 200, 'Level passed!', { fontSize: '64px', fill: '#fff' });
            levelPassed.setOrigin(0.5);
            var moreInfo = this.add.text(400, 300, 'Press any key to continue', { fontSize: '32px', fill: '#fff' });
            moreInfo.setOrigin(0.5);
            this.input.keyboard.once('keydown', function () {
                levelPassed.destroy();
                moreInfo.destroy();
                this.nextLeveLogic()
            },this);

        }
        nextLeveLogic(){
            this.currentLevel++;
            this.allPointsDisabled = false;
            this.levelData = levels[this.currentLevel]
            this.clearPointsAndEnemies()
            this.init()
            this.fillBoardWithPieces()
            this.respawnPlayer()
            this.initScoresText()
            this.setAndReRenderScores();
            this.physics.resume();
        }
        wonScreen() {
            this.setAndReRenderScores()
            this.physics.pause();
            var gameOverText = this.add.text(400, 200, 'You won!', { fontSize: '64px', fill: '#fff' });
            gameOverText.setOrigin(0.5);
            var finalScoreText = this.add.text(400, 300, 'Your score: ' + this.score, { fontSize: '32px', fill: '#fff' });
            var finalBestScoreText = this.add.text(400, 350, 'Your best score: ' + this.bestScore, { fontSize: '32px', fill: '#fff' });
            finalBestScoreText.setOrigin(0.5);
            finalScoreText.setOrigin(0.5);
        }
        clearPointsAndEnemies(){
            this.listOfPoints = []
            this.listOfEnemies = []
        }
        handlePlayerDeath(){
           this.respawnPlayer();
           this.setAndReRenderScoresAfterDeath();
           this.respawnPoints();
           this.respawnEnemies();
        }
        handleGetHit(player, enemy){
            if (this.player.body.touching.down && enemy.body.touching.up) {
                enemy.disableBody(true, true);
                this.player.setVelocityY(-235);
                this.score += 50;
                this.scoreText.setText('Score: ' + this.score);
                this.allEnemiesDisabled = this.areAllEnemiesDisabled()
            }else{
                if (game.getTime() - this.lastHitTime < this.hitCooldown) {
                    return;
                }
                this.healthValue -=30
                this.setHealthBarUIValue();
                if(this.healthValue === 0)
                    this.handlePlayerDeath()

                this.lastHitTime = game.getTime();
            }
        }
        checkCollision (object1, object2) {
            let isColliding = false
            this.physics.add.collider(object1, object2, function() {
                isColliding=true;
            });
            return isColliding
        }
        areAllEnemiesDisabled() {
            var allEnemiesDisabled = true;

            this.listOfEnemies.forEach(function(enemy) {
                if (enemy.enemy.body.enable) {
                    allEnemiesDisabled = false;
                }
            });
            return allEnemiesDisabled;
        }
        reInitHealthBar(){
            this.healthValue = 90;
            this.setHealthBarUIValue()
        }
        respawnPlayer(){
            this.player.setVisible(false);
            this.player.setPosition(this.initialPlayerPosition.x, this.initialPlayerPosition.y);
            this.player.setVisible(true);
            this.reInitHealthBar();
        }
        respawnEnemies(){
            this.listOfEnemies.forEach((enemy) => {
                enemy.enemy.disableBody(true, true);
                enemy.enemy.enableBody(true, enemy.enemy.x, enemy.enemy.y, true, true);
                enemy.enemy.setVelocityX(this.enemySpeed);
            });
        }
        respawnPoints(){
            this.listOfPoints.forEach((point) => {
                point.enableBody(true, point.x, point.y, true, true);
            });
        }
        setAndReRenderScoresAfterDeath(){
            if(this.score > this.bestScore){
                this.bestScore = this.score;
                this.bestScoreText.setText('BestScore: ' + this.bestScore);
            }
            this.score = 0;
            this.scoreText.setText('Score: '+ this.score);
        }
        setAndReRenderScores()
        {
            if(this.score > this.bestScore){
                this.bestScore = this.score;
                this.bestScoreText.setText('BestScore: ' + this.bestScore);
            }
            this.scoreText.setText('Score: '+ this.score);
        }
        addPointToMap(x, y){
            let point = this.points.create(x, y, 'point');
            point.setInteractive();
            this.listOfPoints.push(point)
            this.physics.add.overlap(this.player, point, this.collectPoint, null, this);
        }
        addEnemyToMap(x, y,leftBorder, rightBorder){
            let enemy = this.enemies.create(x, y, 'enemy');
            enemy.setInteractive(false);
            enemy.setCollideWorldBounds(true);
            enemy.setVelocityX(this.enemySpeed);
            this.listOfEnemies.push({"enemy":enemy, "leftBorder":leftBorder,"rightBorder":rightBorder})
            this.physics.add.collider(this.player, enemy, this.handleGetHit, null, this);

        }
        collectPoint(player, point){
            point.disableBody(true, true);
            this.increaseScore()
            this.allPointsDisabled = this.areAllPointsDisabled()
            if(this.allPointsDisabled){
                if(this.currentLevel< this.levelsCount-1){
                    this.nextLevel()
                }else
                    this.wonScreen()
            }
        }
        increaseScore() {
            this.score+=100;
            this.scoreText.setText('Score: ' + this.score);
        }
        areAllPointsDisabled() {
            var allPointsDisabled = true;

            this.listOfPoints.forEach(function(point) {
                if (point.body.enable) {
                    allPointsDisabled = false;
                }
            });
            return allPointsDisabled;
        }
        calculate_pixels(row, column) {
            let x=this.tileSize/2;
            let y=this.tileSize/2;
            let tileX = 0;
            let tileY = 0;
            if(row!==0){
                tileY = this.tileSize;
                tileY=tileY*row
            }
            if(column!==0){
                tileX = this.tileSize;
                tileX=tileX*column
            }
            return {"x":x+tileX, "y":y+tileY}
        }
        makeBar(x, y) {
            let bar = this.add.graphics();
            bar.fillStyle(0xFF0000, 1);
            bar.fillRect(0, 0, 200, 25);
            bar.x = x;
            bar.y = y;

            let outlines = this.add.graphics();
            outlines.lineStyle(4, 0x000000);
            outlines.strokeRect(0, 0, 200, 25);
            outlines.x = x;
            outlines.y = y;

            this.healthValueText = this.add.text(625, 25,'Health: 90', { fontFamily: 'Arial', fontSize: 24, color: '#000000' })

            return bar;
        }
        setHealthBarUIValue() {
            this.healthBar.scaleX = this.healthValue / this.maxHealthValue;
            this.healthValueText.setText('Health: ' + this.healthValue);
        }
        getPlatformUnderEnemy(row, column){
            if(row===0)
                return;
            let underRow = row+1;
            let maxLeft = column;
            let maxRight = column;
            for(let i= column; i>=0;i--){
                maxLeft=i;
                if(this.levelData[underRow][i]===TILE){
                    continue;
                }
                break;
            }
            for(let i= column; i<this.tileXCount;i++){
                maxRight=i;
                if(this.levelData[underRow][i]===TILE)
                    continue;
                break;
            }

            return {"MaxLeft":maxLeft===0 ? maxLeft : maxLeft+1, "MaxRight": maxRight===this.tileXCount-1 ? maxRight : maxRight-1}
        }
    }

    config = {
        type: Phaser.AUTO,
        width: 800,
        height: 570,
        scene: SimpleLevel,
        pixelArt: true,
        physics: {
            default: 'arcade',
            arcade: {
                gravity: { y: 200 }
            }
        }
    };


</script>

</body>
</html>